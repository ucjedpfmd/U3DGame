//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.18408
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using System;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using DCLib.ByteHelper;
using com;
using proto;
namespace com.net.manager
{
	public class ConnMgr
	{
		private static Dictionary<string, List<Delegate>> listeners;
		private static Dictionary<string, Message> listenersData;
		public ConnMgr ()
		{

		}

		public static void init(){
			listeners = new Dictionary<string, List<Delegate>>();
			listenersData = new Dictionary<string, Message>();
            LoopManager.addToFrame("ConnMgr.Loop", loop);
		}

        private static void loop(params object[] arg)
        {
            int len = listeners.Count;
            //List<Delegate> handlers;
            foreach (KeyValuePair<string, List<Delegate>> basehandlers in listeners)
            {
                if (listenersData.ContainsKey(basehandlers.Key) == true)
                {
                    resultHandler(basehandlers.Key, listenersData[basehandlers.Key]);      
                }   
            }

        }

		//注册消息处理函数
		public static void addSocketListener<TMessage>(string command, Action<TMessage> handler) where TMessage : Message 
		{
			List<Delegate> handlers;
			if (listeners.ContainsKey(command) == false)
			{
				handlers = new List<Delegate>();
				listeners[command] = handlers;
			} else {
				handlers = listeners[command];
				if (handlers.IndexOf(handler) == -1){
					return;
				}
			}
			handlers.Add(handler);
		}
		
		//删除消息处理监听
		public static void removeSocketListener<TMessage>(string command, Action<TMessage> handler) where TMessage : Message 
		{
			if (listeners.ContainsKey(command) == false)
			{
				return;
			} 
			List<Delegate> handlers = listeners[command];
			if (handlers != null) {
				int index = handlers.IndexOf(handler);
				if (index != -1) {
					handlers.RemoveAt(index);
				}
			}
		}
		
		public static void resultHandler(string command, Message vo) {
			command = command.ToUpper();
			if (listeners.ContainsKey(command) == false)
			{
				return;
			} 
			List<Delegate> handlers  = listeners[command];
			if (GameParameters.isDebug) {
				for (int i = 0; i < handlers.Count; i++){
					Delegate handler = handlers.ElementAt(i);
					handler.Method.Invoke(null,new object[]{vo});
					
				}
			} else {
				for (int i = 0; i < handlers.Count; i++)
				{
					Delegate handler = handlers.ElementAt(i);
					handler.DynamicInvoke(new object[] { vo });
					//handler.Method.Invoke(null, new m_auth_key_toc[] { vo });
				}
                listenersData.Remove(command);
			}
		}

        public static void addResultData(string command, Message vo)
        {
			command = command.ToUpper();
            listenersData[command] = vo;
        }
	}
}

